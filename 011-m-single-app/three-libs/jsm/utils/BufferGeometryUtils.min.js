import{BufferAttribute as e,BufferGeometry as t,Float32BufferAttribute as r,InstancedBufferAttribute as i,InterleavedBuffer as n,InterleavedBufferAttribute as o,TriangleFanDrawMode as u,TriangleStripDrawMode as s,TrianglesDrawMode as l,Vector3 as a}from"three";function computeTangents(){throw Error("BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.")}function computeMikkTSpaceTangents(t,r,i=!0){if(!r||!r.isReady)throw Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv"))throw Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function n(e){if(e.normalized||e.isInterleavedBufferAttribute){let t=new Float32Array(e.getCount()*e.itemSize);for(let r=0,i=0;r<e.getCount();r++)t[i++]=e.getX(r),t[i++]=e.getY(r),e.itemSize>2&&(t[i++]=e.getZ(r));return t}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}let o=t.index?t.toNonIndexed():t,u=r.generateTangents(n(o.attributes.position),n(o.attributes.normal),n(o.attributes.uv));if(i)for(let s=3;s<u.length;s+=4)u[s]*=-1;return o.setAttribute("tangent",new e(u,4)),t!==o&&t.copy(o),t}function mergeBufferGeometries(e,r=!1){let i=null!==e[0].index,n=new Set(Object.keys(e[0].attributes)),o=new Set(Object.keys(e[0].morphAttributes)),u={},s={},l=e[0].morphTargetsRelative,a=new t,f=0;for(let m=0;m<e.length;++m){let g=e[m],d=0;if(i!==(null!==g.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let b in g.attributes){if(!n.has(b))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+'. All geometries must have compatible attributes; make sure "'+b+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[b]&&(u[b]=[]),u[b].push(g.attributes[b]),d++}if(d!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". Make sure all geometries have the same number of attributes."),null;if(l!==g.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let c in g.morphAttributes){if(!o.has(c))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[c]&&(s[c]=[]),s[c].push(g.morphAttributes[c])}if(r){let h;if(i)h=g.index.count;else{if(void 0===g.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". The geometry must have either an index or a position attribute"),null;h=g.attributes.position.count}a.addGroup(f,h,m),f+=h}}if(i){let p=0,$=[];for(let y=0;y<e.length;++y){let A=e[y].index;for(let B=0;B<A.count;++B)$.push(A.getX(B)+p);p+=e[y].attributes.position.count}a.setIndex($)}for(let w in u){let T=mergeBufferAttributes(u[w]);if(!T)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+w+" attribute."),null;a.setAttribute(w,T)}for(let x in s){let E=s[x][0].length;if(0===E)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[x]=[];for(let G=0;G<E;++G){let z=[];for(let S=0;S<s[x].length;++S)z.push(s[x][S][G]);let v=mergeBufferAttributes(z);if(!v)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+x+" morphAttribute."),null;a.morphAttributes[x].push(v)}}return a}function mergeBufferAttributes(t){let r,i,n,o=0;for(let u=0;u<t.length;++u){let s=t[u];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=s.array.constructor),r!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===i&&(i=s.itemSize),i!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===n&&(n=s.normalized),n!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;o+=s.array.length}let l=new r(o),a=0;for(let f=0;f<t.length;++f)l.set(t[f].array,a),a+=t[f].array.length;return new e(l,i,n)}export function deepCloneAttribute(t){return t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute?deinterleaveAttribute(t):t.isInstancedBufferAttribute?new i().copy(t):new e().copy(t)}function interleaveAttributes(e){let t,r=0,i=0;for(let u=0,s=e.length;u<s;++u){let l=e[u];if(void 0===t&&(t=l.array.constructor),t!==l.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=l.array.length,i+=l.itemSize}let a=new n(new t(r),i),f=0,m=[],g=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let b=0,c=e.length;b<c;b++){let h=e[b],p=h.itemSize,$=h.count,y=new o(a,p,f,h.normalized);m.push(y),f+=p;for(let A=0;A<$;A++)for(let B=0;B<p;B++)y[d[B]](A,h[g[B]](A))}return m}export function deinterleaveAttribute(t){let r=t.data.array.constructor,n=t.count,o=t.itemSize,u=t.normalized,s=new r(n*o),l;l=t.isInstancedInterleavedBufferAttribute?new i(s,o,u,t.meshPerAttribute):new e(s,o,u);for(let a=0;a<n;a++)l.setX(a,t.getX(a)),o>=2&&l.setY(a,t.getY(a)),o>=3&&l.setZ(a,t.getZ(a)),o>=4&&l.setW(a,t.getW(a));return l}export function deinterleaveGeometry(e){let t=e.attributes,r=e.morphTargets,i=new Map;for(let n in t){let o=t[n];o.isInterleavedBufferAttribute&&(i.has(o)||i.set(o,deinterleaveAttribute(o)),t[n]=i.get(o))}for(let u in r){let s=r[u];s.isInterleavedBufferAttribute&&(i.has(s)||i.set(s,deinterleaveAttribute(s)),r[u]=i.get(s))}}function estimateBytesUsed(e){let t=0;for(let r in e.attributes){let i=e.getAttribute(r);t+=i.count*i.itemSize*i.array.BYTES_PER_ELEMENT}let n=e.getIndex();return t+(n?n.count*n.itemSize*n.array.BYTES_PER_ELEMENT:0)}function mergeVertices(t,r=1e-4){r=Math.max(r,Number.EPSILON);let i={},n=t.getIndex(),o=t.getAttribute("position"),u=n?n.count:o.count,s=0,l=Object.keys(t.attributes),a={},f={},m=[],g=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let b=0,c=l.length;b<c;b++){let h=l[b],p=t.attributes[h];a[h]=new e(new p.array.constructor(p.count*p.itemSize),p.itemSize,p.normalized);let $=t.morphAttributes[h];$&&(f[h]=new e(new $.array.constructor($.count*$.itemSize),$.itemSize,$.normalized))}let y=Math.log10(1/r),A=Math.pow(10,y);for(let B=0;B<u;B++){let w=n?n.getX(B):B,T="";for(let x=0,E=l.length;x<E;x++){let G=l[x],z=t.getAttribute(G),S=z.itemSize;for(let v=0;v<S;v++)T+=`${~~(z[g[v]](w)*A)},`}if(T in i)m.push(i[T]);else{for(let I=0,R=l.length;I<R;I++){let U=l[I],X=t.getAttribute(U),_=t.morphAttributes[U],H=X.itemSize,k=a[U],M=f[U];for(let Y=0;Y<H;Y++){let V=g[Y],N=d[Y];if(k[N](s,X[V](w)),_)for(let Z=0,D=_.length;Z<D;Z++)M[Z][N](s,_[Z][V](w))}}i[T]=s,m.push(s),s++}}let P=t.clone();for(let W in t.attributes){let C=a[W];if(P.setAttribute(W,new e(C.array.slice(0,s*C.itemSize),C.itemSize,C.normalized)),W in f)for(let L=0;L<f[W].length;L++){let q=f[W][L];P.morphAttributes[W][L]=new e(q.array.slice(0,s*q.itemSize),q.itemSize,q.normalized)}}return P.setIndex(m),P}function toTrianglesDrawMode(e,t){if(t===l)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t!==u&&t!==s)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e;{let r=e.getIndex();if(null===r){let i=[],n=e.getAttribute("position");if(void 0===n)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let o=0;o<n.count;o++)i.push(o);e.setIndex(i),r=e.getIndex()}let a=r.count-2,f=[];if(t===u)for(let m=1;m<=a;m++)f.push(r.getX(0)),f.push(r.getX(m)),f.push(r.getX(m+1));else for(let g=0;g<a;g++)g%2==0?(f.push(r.getX(g)),f.push(r.getX(g+1)),f.push(r.getX(g+2))):(f.push(r.getX(g+2)),f.push(r.getX(g+1)),f.push(r.getX(g)));f.length/3!==a&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");let d=e.clone();return d.setIndex(f),d.clearGroups(),d}}function computeMorphedAttributes(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;let t=new a,i=new a,n=new a,o=new a,u=new a,s=new a,l=new a,f=new a,m=new a;function g(e,r,a,g,d,b,c,h){t.fromBufferAttribute(r,d),i.fromBufferAttribute(r,b),n.fromBufferAttribute(r,c);let p=e.morphTargetInfluences;if(a&&p){l.set(0,0,0),f.set(0,0,0),m.set(0,0,0);for(let $=0,y=a.length;$<y;$++){let A=p[$],B=a[$];0!==A&&(o.fromBufferAttribute(B,d),u.fromBufferAttribute(B,b),s.fromBufferAttribute(B,c),g?(l.addScaledVector(o,A),f.addScaledVector(u,A),m.addScaledVector(s,A)):(l.addScaledVector(o.sub(t),A),f.addScaledVector(u.sub(i),A),m.addScaledVector(s.sub(n),A)))}t.add(l),i.add(f),n.add(m)}e.isSkinnedMesh&&(e.boneTransform(d,t),e.boneTransform(b,i),e.boneTransform(c,n)),h[3*d+0]=t.x,h[3*d+1]=t.y,h[3*d+2]=t.z,h[3*b+0]=i.x,h[3*b+1]=i.y,h[3*b+2]=i.z,h[3*c+0]=n.x,h[3*c+1]=n.y,h[3*c+2]=n.z}let d=e.geometry,b=e.material,c,h,p,$=d.index,y=d.attributes.position,A=d.morphAttributes.position,B=d.morphTargetsRelative,w=d.attributes.normal,T=d.morphAttributes.position,x=d.groups,E=d.drawRange,G,z,S,v,I,R,U,X=new Float32Array(y.count*y.itemSize),_=new Float32Array(w.count*w.itemSize);if(null!==$){if(Array.isArray(b))for(G=0,S=x.length;G<S;G++)for(R=Math.max((I=x[G]).start,E.start),U=Math.min(I.start+I.count,E.start+E.count),z=R,v=U;z<v;z+=3)c=$.getX(z),g(e,y,A,B,c,h=$.getX(z+1),p=$.getX(z+2),X),g(e,w,T,B,c,h,p,_);else for(R=Math.max(0,E.start),U=Math.min($.count,E.start+E.count),G=R,S=U;G<S;G+=3)c=$.getX(G),g(e,y,A,B,c,h=$.getX(G+1),p=$.getX(G+2),X),g(e,w,T,B,c,h,p,_)}else if(Array.isArray(b))for(G=0,S=x.length;G<S;G++)for(R=Math.max((I=x[G]).start,E.start),U=Math.min(I.start+I.count,E.start+E.count),z=R,v=U;z<v;z+=3)c=z,g(e,y,A,B,c,h=z+1,p=z+2,X),g(e,w,T,B,c,h,p,_);else for(R=Math.max(0,E.start),U=Math.min(y.count,E.start+E.count),G=R,S=U;G<S;G+=3)c=G,g(e,y,A,B,c,h=G+1,p=G+2,X),g(e,w,T,B,c,h,p,_);let H=new r(X,3),k=new r(_,3);return{positionAttribute:y,normalAttribute:w,morphedPositionAttribute:H,morphedNormalAttribute:k}}function mergeGroups(e){if(0===e.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),e;let t=e.groups;if(t=t.sort((e,t)=>e.materialIndex!==t.materialIndex?e.materialIndex-t.materialIndex:e.start-t.start),null===e.getIndex()){let r=e.getAttribute("position"),i=[];for(let n=0;n<r.count;n+=3)i.push(n,n+1,n+2);e.setIndex(i)}let o=e.getIndex(),u=[];for(let s=0;s<t.length;s++){let l=t[s],a=l.start,f=a+l.count;for(let m=a;m<f;m++)u.push(o.getX(m))}e.dispose(),e.setIndex(u);let g=0;for(let d=0;d<t.length;d++){let b=t[d];b.start=g,g+=b.count}let c=t[0];e.groups=[c];for(let h=1;h<t.length;h++){let p=t[h];c.materialIndex===p.materialIndex?c.count+=p.count:(c=p,e.groups.push(c))}return e}export{computeTangents,computeMikkTSpaceTangents,mergeBufferGeometries,mergeBufferAttributes,interleaveAttributes,estimateBytesUsed,mergeVertices,toTrianglesDrawMode,computeMorphedAttributes,mergeGroups};